Όνομα : Μιχάλης Δεικτάκης
ΑΜ: 1115200800018

Compilation:
    make all -> δημιουργεί τα αρχεία poller και pollSwayer
    make server -> δημιουργεί τo αρχείo poller
    make server -> δημιουργεί τo αρχείo pollSwayer

Run server:
    poller [portnum] [numWorkerthreads] [bufferSize] [poll-log file] [poll-stats file]

Run client:
    pollSwayer  [serverName] [portNum] [inputFile.txt]


Λειτουργία Server:

Αρχικά αποφάσισα να δημιουργήσω μια κλάση PollerServer μέσω της οποίας θα επιτευχθούν οι 
λειτουργίες του server. Στο header file έχω συμπεριλάβει τις δηλώσεις των μεταβλητών και των
συναρτήσεων που χρησιμοποιεί ο server οι οποίες εμφανίζουν και κατάλληλα σχόλια ως προς τη Λειτουργία τους.
Υπάρχει ο constructor ο οποίος αρχικοποιεί το instance της κλάσης σύμφωνα με τις παραμέτρους που έχει δόσει 
ο χρήστης.
Η συνάρτηση start() ξεκινάει τον server ανοίγει το αρχείο poll-log και αρχικοποιεί τη μεταβλητή serverInstance_
να δείχνει στο συγκεκριμένο object. Αυτό χρειάστηκε γιατί η signal() δεν μπορεί να δεχτεί function εσωτερική της 
κλάσης οπότε έπρεπε να φτιάξω μια static function την οποία θα καλεί ως signal handler. Στη συνέχεια δημιουργεί
τα worker threads τα οποία καλούν την συνάρτηση workerThread και καλεί την συνάρτηση masterThread η οποία είναι 
υπεύθυνη για τη δημιουργία του socket την αρχικοποίηση του και να ακούει για νέες συνδέσεις. Αν για κάποιο λόγο η 
masterThread επιστρέψει ενημερώνει τα threads να σταματήσουν τη Λειτουργία τους και περιμένει να κάνουν exit().
Τέλος κλείνει το αρχείο poll-log.

Η συνάρτηση masterThread() δημιουργεί και αρχικοποιεί το socket. Αρχικοποιώ το socket με O_NONBLOCK flag 
έτσι ώστε να μην κολάει περιμένοντας νέες συνδέσεις γιατί σε περίπτωση SIGINT δεν θα τερματίσει.
Στη συνέχεια μπαίνει σε ένα loop όσο το flag running_ είναι αληθές και κάνει accept συνδέσεις.
Αν ο buffer έχει χώρο τοποθετεί το fd του client socket στο buffer και ενημερώνει τα worker threads.
Αλλιώς περιμένει σε condition variable μέχρι να έχει χώρο ο buffer ή αν δεχτεί σήμα για να σταματήσει τη 
λειτουργία του.Σε περίπτωση τερματισμού κλείνει το serverSocket.

Η συνάρτηση workerThread()
Ξεκινάει το loop όσο το flag είναι true και προσπαθεί να κάνει lock το mutex περιμένοντας στην condition variable
εφόσον δεν υπάρχει κάποιο fd sto buffer. Αν μπεί κάποιο κάνει lock το mutex και τραβάει το fd που θα εξυπηρετήσει.
Εφόσον έχει fd ξεκινάει την επικοινωνία με τον client για να καταγράψει την ψήφο κοιτάει αν το όνομα υπάρχει ήδη στην
δομή όπου κρατάμε τα ονόματα των υποψηφίων (ένα vector με τα ονόματα). Αν δεν υπάρχει χρησιμοποιώ δεύτερο mutex και 
condition variable για να γράψει ο worker στο αρχείο (αφού αυτό το mutex αφορά μόνο τους workers και όχι το masterThread).
Εφόσον γράψει στο αρχείο την ψήφο ενημερώνει και την αντίστοιχη δομή που κρατά τον αριθμό των ψήφων για το κόμμα.
Αυτή η δομή είναι ένα unordered map με key το όνομα του κόμματος και vlaue τον αριθμό των ψήφων.

Η συνάρτηση handleSignal() είναι υπεύθυνη για τον ομαλό τερματισμό του server σε περίπτωση SIGINT.
Πρώτα ενημερώνει το flag σε false και κάνει broadcast τα cv ώστε να ολοκληρώσουν οι workers την λειτουργία τους.
Στη συνέχεια ανοίγει το pollstats αρχείο και κάνει sort τα αποτελέσματα τα οποία γράφει στο αρχείο και το κλείνει.
Τέλος επιστρέφει ώστε η start να καλέσει το join στα threads και να τερματίσει.

Λειτουργία Client:
Τον client τον έχω υλοποιήσει με μια main η οποία ανοίγει το αρχείο inputFile και για κάθε γραμμή 
δημιουργεί ένα thread το οποίο εκτελεί την συνάρτηση sendVote.
Το κάθε thread επιχυρεί επικοινωνία με τον server μέσω του address και της port στο socket που έχει ανοίξει ο server. 
Σπάει τη γραμμή σε όνομα voter και party και καλώντας τις send και recv στέλνει την ψήφο στο worker thread που έχει αναλάβει
την επικοινωνία. Τέλος κλείνει το clientSocket και επιστρέφει.
